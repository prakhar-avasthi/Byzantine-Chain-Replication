import pickle
import nacl.encoding
import nacl.signing
import nacl.hash
import sys
import copy

class Olympus(process):
    def setup(num_replica, head_timeout, nonhead_timeout, failure_list):
        output("Olympus:>> Setup")
        output("Failure_list is:", failure_list)
        class_config = import_da('Configuration')
        self.config = class_config.Configuration()
        self.replica_public_keys = []
        self.replica_failure_map = {}


    def run():
        output("Olympus:>> Started")
        await(some(received(('terminate_olympus'))))


    def receive(msg = ('req_get_current_configuration', client)):
        output("Olympus:>> Received req_get_current_configuration from Client")
        if self.config.config_id is None:
            output("Olympus:>> Configuration is NONE")
            makeNewConfiguration()

        output("Olympus:>> Replying res_get_current_configuration with configuration")
        send(('res_get_current_configuration', self.config, self.replica_public_keys), to=client)


    def makeNewConfiguration():
        output("Olympus:>> Making New Configuration")
        if self.config.config_id is None:
            self.config.config_id = 1
        else:
            self.config.config_id += 1

        replicaList = []
        replicaList = new(Replica, num= self.num_replica)

        public_keys = []
        private_keys = []

        for i in range(self.num_replica):
            import nacl
            signing_key = nacl.signing.SigningKey.generate()
            private_keys.append(signing_key)
            public_keys.append(signing_key.verify_key)
        parse_failures()

        i = 0
        for replica in replicaList:
            failure_map = replica_failure_map[str(i)] if str(i) in self.replica_failure_map else {}
            if i is 0:
                setup(replica, args=(self, list(replicaList), i, 'head', dict(), dict(), public_keys, private_keys[i], head_timeout, 'PENDING', failure_map))
            elif i is num_replica-1:
                setup(replica, args=(self, list(replicaList), i, 'tail', dict(), dict(), public_keys, private_keys[i], nonhead_timeout, 'PENDING', failure_map))
            else:
                setup(replica, args=(self, list(replicaList), i, 'normal_replica', dict(), dict(),  public_keys, private_keys[i], nonhead_timeout, 'PENDING', failure_map))
            i += 1

        self.config.list_replica = list(replicaList)
        self.replica_public_keys = public_keys
        start(replicaList)

        #i = 0
        #for i in range(self.num_replica):
            #if i is 0:
                #if str(i) in self.replica_failure_map:
                    #replica = new(Replica, args=(self, None, i, 'head', dict(), dict(), public_keys, private_keys[i], head_timeout, 'PENDING', self.replica_failure_map[str(i)]), at='ReplicaNode'+str(i))
                #else:
                    #replica = new(Replica, args=(self, None, i, 'head', dict(), dict(), public_keys, private_keys[i], head_timeout, 'PENDING', {}), at='ReplicaNode'+str(i))
            #elif i is num_replica-1:
                #if str(i) in self.replica_failure_map:
                    #replica = new(Replica, args=(self, None, i, 'tail', dict(), dict(), public_keys, private_keys[i], nonhead_timeout, 'PENDING', self.replica_failure_map[str(i)]), at='ReplicaNode'+str(i))
                #else:
                    #replica = new(Replica, args=(self, None, i, 'tail', dict(), dict(), public_keys, private_keys[i], nonhead_timeout, 'PENDING', {}), at='ReplicaNode'+str(i))
            #else:
                #if str(i) in self.replica_failure_map:
                    #replica = new(Replica, args=(self, None, i, 'normal_replica', dict(), dict(),  public_keys, private_keys[i], nonhead_timeout, 'PENDING', self.replica_failure_map[str(i)]), at='ReplicaNode'+str(i))
                #else:
                    #replica = new(Replica, args=(self, None, i, 'normal_replica', dict(), dict(),  public_keys, private_keys[i], nonhead_timeout, 'PENDING', {}), at='ReplicaNode'+str(i))
            #start(replica)
            #replicaList.append(replica)
            #i += 1

        #self.config.list_replica = replicaList
        #self.replica_public_keys = public_keys
        #for replica in replicaList:
            #send(('init_hist', list(replicaList)), to=replica)

    def parse_failures():
        output("Parsing failures")
        for failure in self.failure_list:
            import re
            failure_replica = None
            failure_type = None
            source = None
            client_id = None
            message_number = None

            matches = re.findall(r"\[(.+?)\]", failure[0])
            failure_replica = matches[0].split(",")[1]

            failures_injected = failure[1].split(";")
            for failure_type in failures_injected:
                failure_row = re.findall(r'(?:[^,(]|\([^)]*\))+', failure_type)
                matches = re.findall(r"\((.+?)\)", failure_row[0])
                client_id, message_number = matches[0].split(",")
                source = failure_row[0].split("(")[0]
                failure_type = failure_row[1]

            try:
                self.replica_failure_map[str(failure_replica)][str(failure_type).strip()] = (source,(client_id, message_number))
            except KeyError:
                self.replica_failure_map[str(failure_replica)] = {str(failure_type).strip(): (source,(client_id, message_number))}


class Replica(process):
    ##[TODO: take more parameters for the code to run successfully]
    def setup(olympus, replicaList, index, type, database, history, public_keys, private_key, timeout, state, fault_map):
        self.forwarded_request = {}
        self.shuttle_request = {}
        self.direct_client_request = {}
        self.result_shuttle_request = {}
        self.waiting_for_result = {}


    def run():
        self.state = 'ACTIVE'
        output("Replica",self.index,":>> Replica Started with a private key: ", self.type, self.state)
        await(some(received(('terminate_replica'))))


    def performOperation(operation):
        output("Replica",self.index,":>> perform operation: ", operation.command)
        import re
        matches = re.findall(r"\'(.+?)\'", operation.command)

        key = None
        value = None

        if not operation.type is 2 :
            key = matches[0]
            value = matches[1]
        else:
            key = matches[0]

        if operation.type is 1:
            self.database[key] = value
            return 'OK'
        elif operation.type is 2:
            if key in self.database:
                return self.database[key]
            else:
                return ''
        elif operation.type is 3:
            limit = value.split(':')
            if key in self.database and len(self.database[key]) >= int(limit[1]):
                val = self.database[key]
                self.database[key] = val[int(limit[0]):int(limit[1])]
                return 'OK'
            else:
                return 'FAIL'
        elif operation.type is 4:
            if key in self.database:
                val = self.database[key]
                list_val = val+value
                self.database[key] = list_val
                return 'OK'
            else:
                return 'FAIL'


    def receive(msg = ('init_hist', replica_list)):
        self.state = 'ACTIVE'
        self.replicaList = replica_list


    def receive(msg = ('req_operation', operation, client, client_index)):
        ## If the replica is head node, it will create a forward shuttle
        if self.type == 'head' and state == 'ACTIVE':
            output("Replica",self.index,":>> Received req_operation from Client", client_index, " operation: ", operation.command)

            result = None
            try:
                self.forwarded_request[client_index] += 1
            except KeyError:
                self.forwarded_request[client_index] = 1

            class_action = import_da('Action')
            action = class_action.Action()
            action.seq_id = self.forwarded_request[client_index]
            action.operation = operation
            order_proof = []
            result_proof = []

            class_order_statement = import_da('OrderStatement')
            order_statement = class_order_statement.OrderStatement()
            order_statement.order = "order"

            if client_index in self.forwarded_request and self.is_failure_change_operation("forwarded_request", str(client_index), str(self.forwarded_request[client_index])):
                output("Replica",self.index,":>> Fault Change operation injected from client ", client_index, " Corresponding to request ",self.forwarded_request[client_index])
                temp_action = copy.deepcopy(action)
                temp_action.operation.type = 2
                temp_action.operation.command = "('X')"
                order_statement.action = temp_action
                output("Replica",self.index,":>> Successfully changed the operation to get('X')")
                result = performOperation(temp_action.operation)

            elif client_index in self.forwarded_request and self.is_failure_change_result("forwarded_request", str(client_index), str(self.forwarded_request[client_index])):
                output("Replica",self.index,":>> Fault Change result injected from client ", client_index, " Corresponding to request ",self.forwarded_request[client_index])
                order_statement.action = action
                result = "OK"
                output("Replica",self.index,":>> Successfully changed the result to OK")
            else:
                output("Replica",self.index,":>> No fault Injected ", client_index, " Corresponding to request ",self.forwarded_request[client_index])
                order_statement.action = action
                result = performOperation(action.operation)


            # signing order proof
            signed_order_statement = self.private_key.sign(pickle.dumps(order_statement))

            order_proof.append(signed_order_statement)
            ##output("Replica",self.index,":>> Successfully signed and appended order_statement", signed_order_statement)

            class_result_statement = import_da('ResultStatement')
            result_statement = class_result_statement.ResultStatement()
            result_statement.result_const = "result"
            result_statement.action = action

            ## calculate the result digest
            HASHER = nacl.hash.sha256
            result_byte = pickle.dumps(result)
            result_digest = HASHER(result_byte, encoder=nacl.encoding.HexEncoder)

            result_statement.result= result_digest

            # signing result proof
            signed_result_statement = self.private_key.sign(pickle.dumps(result_statement))
            result_proof.append(signed_result_statement)
            output("Replica",self.index,":>> Successfully signed the result proof by head")

            ## create a forward shuttle and send
            class_shuttle = import_da('Shuttle')
            forward_shuttle = class_shuttle.Shuttle()
            forward_shuttle.action = action
            forward_shuttle.order_proof = order_proof
            forward_shuttle.result_proof = result_proof
            output("Replica",self.index,":>> Forwarding shuttle to Replica",index+1, " operation: ", action.operation.command)
            send(('forward_shuttle', self, forward_shuttle, client, client_index), to = self.replicaList[index + 1])


    def receive(msg = ('forward_shuttle', replica, forward_shuttle, client, client_index)):
        action = forward_shuttle.action
        output("Replica",self.index,":>> Received forward_shuttle from previous replica, operation: ", action.operation.command)

        result = None
        try:
            self.shuttle_request[client_index] += 1
        except KeyError:
            self.shuttle_request[client_index] = 1

        ## fetch result proof and order proof list from the forward shuttle
        order_proof = forward_shuttle.order_proof
        result_proof = forward_shuttle.result_proof

        ##validating the orderproof
        for i in range(len(order_proof)) :
            try:
                public_keys[i].verify(order_proof[i])
            except Exception:
                output("Replica",self.index,":>> Key doesnot verify, State changed to Immutable, Nofitying Wedge to Olympus")
                self.state = 'IMMUTABLE'
                send(('wedged', self, self.index, self.database), to = olympus)
                ##send(('terminate_shuttle', to = self.replicaList[index])

        ## normal replica will fetch the order and result proof list and add its own and send to next replica
        if type == 'normal_replica' and state == 'ACTIVE':

            verify_key = self.private_key.verify_key

            ## make its own order proof and append it to the order proof list
            class_order_statement = import_da('OrderStatement')
            order_statement = class_order_statement.OrderStatement()
            order_statement.order = "order"

            ##fault injection scenario
            if client_index in self.shuttle_request and self.is_failure_change_operation("shuttle",str(client_index), str(self.shuttle_request[client_index])):
                output("Replica",self.index,":>> Fault Change operation injected from client ", client_index, " Corresponding to request ",self.shuttle_request[client_index])
                temp_action = copy.deepcopy(action)
                temp_action.operation.type = 2
                temp_action.operation.command = "('X')"
                order_statement.action = temp_action
                result = performOperation(temp_action.operation)
            elif client_index in self.shuttle_request and self.is_failure_change_result("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                output("Replica",self.index,":>> Fault Change result injected from client ", client_index, " Corresponding to request ",self.shuttle_request[client_index])
                order_statement.action = action
                result = "OK"
            elif client_index in self.shuttle_request and self.is_failure_drop_result_stmt("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                output("Replica",self.index,":>> Fault Omit Head Result injected from client ", client_index, " Corresponding to request ",self.shuttle_request[client_index])
                order_statement.action = action
                result = performOperation(action.operation)
                del result_proof[0]
            else:
                output("Replica",self.index,":>> No fault Injected ", client_index, " Corresponding to request ",self.shuttle_request[client_index])
                order_statement.action = action
                result = performOperation(action.operation)


            signed_order_statement = self.private_key.sign(pickle.dumps(order_statement))
            order_proof.append(signed_order_statement)

            ## make its own result proof and append it to the result proof list
            class_result_statement = import_da('ResultStatement')
            result_statement = class_result_statement.ResultStatement()
            result_statement.result_const = "result"
            result_statement.action = action

            ## calculate the result digest
            HASHER = nacl.hash.sha256
            result_byte = pickle.dumps(result)
            result_digest = HASHER(result_byte, encoder=nacl.encoding.HexEncoder)
            result_statement.result= result_digest

            # signing result proof
            signed_result_statement = self.private_key.sign(pickle.dumps(result_statement))

            ## appending result proof
            result_proof.append(signed_result_statement)

            ## output("Replica result proof size",self.index,":>>", len(result_proof))
            ## output("Replica order proof size",self.index,":>>", len(order_proof))

            ## send the shuttle to next replica
            output("Replica",self.index,":>> Forwarding shuttle to Replica: ", index+1, " operation: ", action.operation.command)
            send(('forward_shuttle', self, forward_shuttle, client, client_index), to = self.replicaList[index + 1])


        ## If replica is a tail node, it will create a result shuttle
        if type == 'tail' and state == 'ACTIVE':

            ## make its own order proof and append it to the order proof list
            class_order_statement = import_da('OrderStatement')
            order_statement = class_order_statement.OrderStatement()
            order_statement.order = "order"


            if client_index in self.shuttle_request and self.is_failure_change_operation("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                output("Replica",self.index,":>> Fault Change operation injected from client ", client_index, " Corresponding to request ",self.shuttle_request[client_index])
                temp_action = copy.deepcopy(action)
                temp_action.operation.type = 2
                temp_action.operation.command = "('X')"
                order_statement.action = temp_action
                result = performOperation(temp_action.operation)
            elif client_index in self.shuttle_request and  self.is_failure_change_result("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                output("Replica",self.index,":>> Fault Change result injected from client ", client_index, " Corresponding to request ",self.shuttle_request[client_index])
                order_statement.action = action
                result = "OK"
            elif client_index in self.shuttle_request and self.is_failure_drop_result_stmt("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                output("Replica",self.index,":>> Fault Omit Head Result injected from client ", client_index, " Corresponding to request ",self.shuttle_request[client_index])
                order_statement.action = action
                result = performOperation(action.operation)
                del result_proof[0]
            else:
                output("Replica",self.index,":>> No fault Injected ", client_index, " Corresponding to request ",self.shuttle_request[client_index])
                order_statement.action = action
                result = performOperation(action.operation)

            order_statement.action = action
            order_proof.append(order_statement)

            ## make its own result proof and append it to the result proof list
            class_result_statement = import_da('ResultStatement')
            result_statement = class_result_statement.ResultStatement()
            result_statement.result_const = "result"
            result_statement.action = action

            ## calculate the result digest
            HASHER = nacl.hash.sha256
            result_byte = pickle.dumps(result)
            result_digest = HASHER(result_byte, encoder=nacl.encoding.HexEncoder)
            result_statement.result = result_digest

            # signing result proof
            signed_result_statement = self.private_key.sign(pickle.dumps(result_statement))
            result_proof.append(signed_result_statement)

            ## send result to client
            ##send(('res_operation', action.operation, result, result_proof), to=client)
            output("Replica",self.index,":>> Replied res_operation to Client: ", action.operation.command, " result: ", result)

            ## make a new result shuttle
            class_shuttle = import_da('Shuttle')
            result_shuttle = class_shuttle.Shuttle()

            result_shuttle.action = action
            ##result_shuttle.order_proof = order_proof
            result_shuttle.result_proof = result_proof
            self.history[action] = (result_shuttle, result)
            output("[Replica",self.index,":>>] Sending result shuttle back to replica: ", index-1, " operation: ", action.operation.command)
            send(('result_shuttle', self, result_shuttle, result), to = self.replicaList[index - 1])


    ## [TODO] take result as a parameter too
    ## [TODO] validate the result shuttle
    # on receiving result shuttle replica will store result shuttle into its cache and start awaiting for forward shuttle
    def receive(msg = ('result_shuttle', replica, result_shuttle, result)):

        flag_not_verified = False

        ## validating result proof
        for i in range(len(result_shuttle.result_proof)):
            try:
                public_keys[i].verify(result_shuttle.result_proof[i])
            except Exception:
                flag_not_verified = True
                output("Replica",self.index,":>> Result proof doesnot verify, State changed to Immutable, Nofitying Wedge to Olympus")
                self.state = 'IMMUTABLE'
                send(('wedged', self, self.index, self.database), to = olympus)
                ##send(('terminate_shuttle', to = self.replicaList[index])

        ## if result proof is verified
        if not flag_not_verified  and state == 'ACTIVE':
            action = result_shuttle.action
            self.history[action] = (result_shuttle, result)

            if action.operation.client_request_id in self.waiting_for_result:
                wait_operation = self.waiting_for_result[action.operation.client_request_id]
                if wait_operation[0] == 1 and\
                    wait_operation[1] == action.operation.client_seq_id:
                    wait_operation[0] = 0
                    wait_operation[1] = None
                    self.waiting_for_result[action.operation.client_request_id] = wait_operation

            output("Replica",self.index,":>> Got a result shuttle and its verified", self.history[action])
            output("Replica",self.index,":>> Received result_shuttle from previous replica: ", action.operation.command)

            if not type == 'head' and state == 'ACTIVE':
                ## send the shuttle to next replica
                output("Replica",self.index,":>> Sending result shuttle back to replica: ", index-1, " operation: ", action.operation.command)
                send(('result_shuttle', self, result_shuttle, result), to = replicaList[index - 1])

    def receive(msg = ('req_operation_timeout', operation, client, client_index)):
        if self.state == 'ACTIVE':
            output("Replica",self.index,":<< DIRECT REQUEST FROM CLIENT: ", client_index, "for operation: ", operation.command)
            (found_in_history, action) = foundInHistory(operation)

            if found_in_history == True:

                try:
                    (result_shuttle, result) = self.history[action]
                    output("######################################Found in history######################################")
                    send(('res_operation_timeout', operation, result_shuttle.result_proof, result, self, self.index, None), to=client)
                except Exception:
                    output(self.index, 'Error')

                result = None
                try:
                    self.direct_client_request[client_index] += 1
                except KeyError:
                    self.direct_client_request[client_index] = 1

                ##fault injection scenario
                if client_index in self.shuttle_request and self.is_failure_change_result("client_request", str(client_index), str(self.direct_client_request[client_index])):
                    output("Replica",self.index,":>> Fault Change result injected from client ", client_index, " Corresponding to request ",self.direct_client_request[client_index])
                    temp_result = "OK"

                    ## calculate the result digest
                    import nacl
                    HASHER = nacl.hash.sha256
                    result_byte = pickle.dumps(temp_result)
                    result_digest = HASHER(result_byte, encoder=nacl.encoding.HexEncoder)

                    ## unsign the result statement and overwrite the new result
                    result_statement = result_shuttle.result_proof[self.index]
                    unsigned_result_statement = pickle.loads(self.public_keys[self.index].verify(result_statement))
                    unsigned_result_statement.result = result_digest

                    ## resign the result_statement and replace it in result_proof
                    signed_result_statement = self.private_key.sign(pickle.dumps(unsigned_result_statement))
                    result_shuttle.result_proof[self.index] = signed_result_statement


                elif client_index in self.shuttle_request and self.is_failure_drop_result_stmt("client_request", str(client_index), str(self.direct_client_request[client_index])):
                    output("Replica",self.index,":>> Fault Omit Head Result injected from client ", client_index, " Corresponding to request ",self.direct_client_request[client_index])
                    del result_shuttle.result_proof[0]

            elif found_in_history == False and not self.type == 'head':
                output("Replica",self.index,": Forward Retransmit to Head.")
                send(('req_operation_timeout', operation, client, client_index), to=self.replicaList[0])
                self.waiting_for_result[operation.client_request_id] = (1, operation.client_seq_id)
                if await(self.waiting_for_result[operation.client_request_id][0] == 0):
                    output("Replica",self.index,":Got result!, Stop Timer!")
                elif timeout(self.timeout):
                    output("Replica",self.index,":Timeout!! Sending Reconfig Request")
                    self.waiting_for_result[operation.client_request_id] = (0, None)
            elif found_in_history == False and self.type == 'head':
                if operation.client_seq_id > self.forwarded_request[client_index]:
                    #treat as new request
                    send(('req_operation', operation, client, client.index), to=self)
                else:
                    self.waiting_for_result[operation.client_request_id] = (1, operation.client_seq_id)
                    if await(self.waiting_for_result[operation.client_request_id][0]== 0):
                        output("Replica",self.index,":Got result!, Timer expire!")
                    elif timeout(self.timeout):
                        output("Replica",self.index,":Timeout!! Sending Reconfig Request")
                        self.waiting_for_result[operation.client_request_id] = (0, None)
        elif self.state == 'IMMUTABLE':
            send(('res_operation_timeout', None, None, None, self, self.index, 'error'), to=client)

    def foundInHistory(operation):
        for action in self.history.keys():
            if action.operation.client_request_id == operation.client_request_id and\
                action.operation.command == operation.command and\
                action.operation.client_seq_id == operation.client_seq_id and\
                action.operation.type == operation.type:
                    return (True, action)
        return (False, None)

    def is_failure_change_operation(type, client, message):

        try:
            (source, (c,m)) = self.fault_map["change_operation()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_change_result(type, client, message):
        output("############ change result ##################", fault_map, type, client, message)
        try:
            (source, (c,m)) = fault_map["change_result()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_drop_result_stmt(type, client, message):

        try:
            (source, (c,m)) = fault_map["drop_result_stmt()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False




def main():
    config = {}
    failure_list = []
    with open('config.txt','r') as f:
      for line in f:
          if line[0] != '#':
            (key,sep,val) = line.partition('=')
            # if the line does not contain '=', it is invalid and hence ignored
            if len(sep) != 0:
                val = val.strip()
                config[key.strip()] = int(val) if str.isdecimal(val) else val

    #class_olympus = import_da('Olympus')
    class_client = import_da('Client')
    num_replica = 2 * config['t'] + 1

    for key in config:
        if "failures" in key:
            failure_list.append((key,config[key]))

    olympus = new(Olympus, args=(num_replica, config['head_timeout'], config['nonhead_timeout'], failure_list), at='OlympusNode')
    clientList = new(class_client.Client, num= config['num_client'])
    i = 0
    for client in clientList:
        load = 'workload[' + str(i) + ']'
        setup(client, args=(olympus, i, config[str(load)], config['client_timeout']))
        i += 1

    config(channel = Fifo, clock = Lamport)
    start(olympus)
    start(clientList)
