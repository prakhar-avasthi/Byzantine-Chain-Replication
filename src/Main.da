import nacl.encoding
import nacl.signing
import nacl.hash

class Olympus(process):
    def setup(num_replica, head_timeout, nonhead_timeout, failure_list):
        output("Olympus:>> Setup")
        output("Failure_list is:", failure_list)
        class_config = import_da('Configuration')
        self.config = class_config.Configuration()
        self.replica_public_keys = []
        self.replica_failure_map = {}


    def run():
        output("Olympus:>> Started")
        await(some(received(('terminate_olympus'))))


    def receive(msg = ('req_get_current_configuration', client)):
        output("Olympus:>> Received req_get_current_configuration from Client")
        if self.config.config_id is None or self.config.config_id is None:
            output("Olympus:>> Configuration is NONE")
            makeNewConfiguration()

        output("Olympus:>> Replying res_get_current_configuration with configuration")
        send(('res_get_current_configuration', self.config, self.replica_public_keys), to=client)


    def makeNewConfiguration():
        output("Olympus:>> Making New Configuration")
        if self.config.config_id is None:
            self.config.config_id = 1
        else:
            self.config.config_id += 1

        class_replica = import_da('Replica')
        replicaList = new(class_replica.Replica, num= self.num_replica)

        ##output("Olympus:>> Setting up Replicas with : ", signing_key)

        public_keys = []
        private_keys = []

        for i in range(len(replicaList)):
            import nacl
            signing_key = nacl.signing.SigningKey.generate()
            private_keys.append(signing_key)
            public_keys.append(signing_key.verify_key)

        parse_failures()
        ##output("Failure list after parsing is", self.replica_failure_map)

        i = 0
        for replica in replicaList:
            if i is 0:
                if(str(i) in self.replica_failure_map):
                    setup(replica, args=(self, list(replicaList), i, 'head', dict(), dict(), public_keys, private_keys[i], head_timeout, 'PENDING', self.replica_failure_map[str(i)]))
                else:
                    setup(replica, args=(self, list(replicaList), i, 'head', dict(), dict(), public_keys, private_keys[i], head_timeout, 'PENDING', {}))
            elif i is num_replica-1:
                if(str(i) in self.replica_failure_map):
                    setup(replica, args=(self, list(replicaList), i, 'tail', dict(), dict(), public_keys, private_keys[i], nonhead_timeout, 'PENDING', self.replica_failure_map[str(i)]))
                else:
                    setup(replica, args=(self, list(replicaList), i, 'tail', dict(), dict(), public_keys, private_keys[i], nonhead_timeout, 'PENDING', {}))
            else:
                if(str(i) in self.replica_failure_map):
                    setup(replica, args=(self, list(replicaList), i, 'normal_replica', dict(), dict(),  public_keys, private_keys[i], nonhead_timeout, 'PENDING', self.replica_failure_map[str(i)]))
                else:
                    setup(replica, args=(self, list(replicaList), i, 'normal_replica', dict(), dict(),  public_keys, private_keys[i], nonhead_timeout, 'PENDING', {}))
            i += 1
        self.config.list_replica = list(replicaList)
        self.replica_public_keys = public_keys
        start(replicaList)

    def parse_failures():
            output("Parsing failures")
            for failure in self.failure_list:
                import re
                output("###########In Loop##########")
                failure_replica = None
                failure_type = None
                source = None
                client_id = None
                message_number = None

                matches = re.findall(r"\[(.+?)\]", failure[0])
                failure_replica = matches[0].split(",")[1]

                failures_injected = failure[1].split(";")
                for failure_type in failures_injected:
                    failure_row = re.findall(r'(?:[^,(]|\([^)]*\))+', failure_type)
                    matches = re.findall(r"\((.+?)\)", failure_row[0])
                    client_id, message_number = matches[0].split(",")
                    source = failure_row[0].split("(")[0]
                    failure_type = failure_row[1]

                output("########### Failures are #########", failure_replica, failure_type, source, client_id, message_number)
                output("########### Map is ##############", self.replica_failure_map)
                ##if not failure_replica in self.replica_failure_map:
                    ##self.replica_failure_map[failure_replica] = {}
                try:
                    self.replica_failure_map[str(failure_replica)][str(failure_type)] = (source,(client_id, message_number))
                except KeyError:
                    output("############### Key Error ############",)
                    self.replica_failure_map[str(failure_replica)] = {str(failure_type): (source,(client_id, message_number))}
            output("###########", self.replica_failure_map)

def main():
    config = {}
    failure_list = []
    with open('config.txt','r') as f:
      for line in f:
          if line[0] != '#':
            (key,sep,val) = line.partition('=')
            # if the line does not contain '=', it is invalid and hence ignored
            if len(sep) != 0:
                val = val.strip()
                config[key.strip()] = int(val) if str.isdecimal(val) else val

    #class_olympus = import_da('Olympus')
    class_client = import_da('Client')
    num_replica = 2 * config['t'] + 1

    for key in config:
        if "failures" in key:
            failure_list.append((key,config[key]))

    olympus = new(Olympus, args=(num_replica, config['head_timeout'], config['nonhead_timeout'], failure_list), at='OlympusNode')
    clientList = new(class_client.Client, num= config['num_client'])
    i = 0
    for client in clientList:
        load = 'workload[' + str(i) + ']'
        setup(client, args=(olympus, i, config[str(load)], config['client_timeout']))
        i += 1

    config(channel = Fifo, clock = Lamport)
    start(olympus)
    start(clientList)
