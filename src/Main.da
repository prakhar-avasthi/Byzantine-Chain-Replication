import pickle
import nacl
import sys

class Olympus(process):
    def setup(num_replica, head_timeout, nonhead_timeout, failure_list):
        output("[Olympus:] Setup")
        class_config = import_da('Configuration')
        self.config = class_config.Configuration()
        self.replica_public_keys = []
        self.replica_failure_map = {}
        self.num_wedged_message = 0
        self.num_caughtup_message = 0
        self.wedged_data = {}
        self.max_checkpoint = {}
        self.longest_history = None
        self.longest_database = None

    def run():
        output("[Olympus:] Started")
        await(some(received(('terminate_olympus'))))

    def receive(msg = ('req_get_current_configuration', client)):
        output("[Olympus:]<< req_get_current_configuration")
        if self.config.config_id is None:
            makeNewConfiguration({}, [])

        output("[Olympus:]>> res_get_current_configuration")
        send(('res_get_current_configuration', self.config, self.replica_public_keys), to=client)

    def receive(msg = ('req_current_status', client)):
        output("[Olympus:]<< req_current_status")
        output("[Olympus:]>> res_current_status: ", self.config.config_id)
        send(('res_current_status', self.config.config_id), to=client)

    def receive(msg = ('req_re_configuration', config_id)):
        output("[Olympus:]<< req_re_configuration")
        if config_id == self.config.config_id:
            for i in range(len(self.config.list_replica)):
                output("[Olympus:]>> wedge to Replica: ", i)
                send(('wedge'), to = self.config.list_replica[i])
        else:
            output("[Olympus:]Reconfig request from old configuration, ignoring!")

    def receive(msg = ('wedged', database, history, checkpoint_proof, checkpoint_position, replica_id)):
        output("[Olympus:]<< wegded from Replica: ", replica_id, " : History length: ", len(history), " : ChkPoint", checkpoint_position)
        ##[TODO] check validation of checkpoint proof
        try:
            self.max_checkpoint[checkpoint_position] += 1
        except:
            self.max_checkpoint[checkpoint_position] = 1

        self.num_wedged_message += 1
        self.wedged_data[replica_id] = (checkpoint_position, database, history)
        output("[Olympus:] Total received: ", self.num_wedged_message)

        if(self.num_wedged_message == len(self.config.list_replica)):
            self.num_wedged_message = 0
            max = -1
            for key in self.wedged_data:
                val = self.wedged_data[key]
                if len(val[2]) > max:
                    max = len(val[2])
                    self.longest_history = val[2]
                    self.longest_database = val[1]

            output("[Olympus:] Longest History")
            for i in range(len(self.longest_history)):
                ((action, result), proof) = self.longest_history[i]
                output("[Olympus:] Longest History: Slot: ", action.replica_slot, ", Operation: ", action.operation.toString())

            output("[Olympus:] Longest Database: ", self.longest_database)

            for i in range(len(self.config.list_replica)):
                (pos, db, hist) = self.wedged_data[i]
                catch_up_history = calculateCatchUpHistory(i, self.longest_history, hist)
                send(('catch-up', catch_up_history), to = self.config.list_replica[i])

    def receive(msg = ('caught-up', database, replica_id)):
        output("[Olympus:]<< caught-up from Replica: ", replica_id, " : database: ", database)
        self.num_caughtup_message += 1
        if(self.num_caughtup_message == len(self.config.list_replica)):
            makeNewConfiguration(self.longest_database, self.longest_history)

    def calculateCatchUpHistory(replica_id, longest_history, own_history):
        catch_up_history = []
        for i in range(len(self.longest_history)):
            record = self.longest_history[i]
            if not presentInHistory(replica_id, record, own_history):
                catch_up_history.append(record)
        return catch_up_history

    def presentInHistory(id, record, own_history):
        ((record_action, record_result), record_proof) = record
        for i in range(len(own_history)):
            ((action, result), proof) = own_history[i]
            if action.replica_slot == record_action.replica_slot:
                return True
        return False

    def makeNewConfiguration(database, history):
        output("[Olympus:] Making New Configuration")
        if self.config.config_id is None:
            self.config.config_id = 0
        else:
            self.config.config_id += 1

        replicaList = []
        replicaList = new(Replica, num= self.num_replica)

        public_keys = []
        private_keys = []

        for i in range(self.num_replica):
            signing_key = nacl.signing.SigningKey.generate()
            private_keys.append(signing_key)
            verify_key = signing_key.verify_key
            verify_key_hex = verify_key.encode(encoder=nacl.encoding.HexEncoder)
            public_keys.append(verify_key_hex)
        parse_failures()

        i = 0
        for replica in replicaList:
            failure_map = replica_failure_map[(str(self.config.config_id), str(i))] if (str(self.config.config_id), str(i)) in self.replica_failure_map else {}
            output("Failure map is : ", failure_map, " ", i)

            if i is 0:
                setup(replica, args=(self, self.config.config_id, list(replicaList), i, 'head', dict(database), list(history)\
                    , public_keys, private_keys[i], head_timeout, 'PENDING', failure_map))
            elif i is num_replica-1:
                setup(replica, args=(self, self.config.config_id, list(replicaList), i, 'tail', dict(database)\
                        , list(history), public_keys, private_keys[i], nonhead_timeout, 'PENDING', failure_map))
            else:
                setup(replica, args=(self, self.config.config_id, list(replicaList), i, 'normal_replica'\
                        , dict(database), list(history),  public_keys, private_keys[i], nonhead_timeout, 'PENDING', failure_map))
            i += 1

        self.config.list_replica = list(replicaList)
        self.replica_public_keys = public_keys
        start(replicaList)

    def parse_failures():
        for failure in self.failure_list:
            import re
            failure_replica = None
            failure_type = None
            source = None
            client_id = None
            message_number = None

            matches = re.findall(r"\[(.+?)\]", failure[0])

            config_replica = matches[0].split(",")
            failure_config = config_replica[0]
            failure_replica = config_replica[1]

            failures_injected = failure[1].split(";")

            for failure_type in failures_injected:
                failure_row = re.findall(r'(?:[^,(]|\([^)]*\))+', failure_type)
                matches = re.findall(r"\((.+?)\)", failure_row[0])
                to_match = matches[0].split(",")
                client_id = -1
                message_mumber = 0
                if(len(to_match) > 1) :
                    client_id, message_number = matches[0].split(",")
                elif(len(to_match) == 1):
                    message_number = to_match[0]
                source = failure_row[0].split("(")[0]
                failure_type = failure_row[1]

                try:
                    self.replica_failure_map[(str(failure_config).strip(), str(failure_replica).strip())][str(failure_type).strip()]\
                                        = (source.strip(),(client_id, message_number))
                except KeyError:
                    self.replica_failure_map[(str(failure_config).strip(), str(failure_replica).strip())]\
                                        = {str(failure_type).strip(): (source.strip(),(client_id, message_number))}

class Replica(process):
    def setup(olympus, config_id, replicaList, index, type, database, history, public_keys, private_key, timeout, state, fault_map):
        self.forwarded_request = {}
        self.shuttle_request = {}
        self.direct_client_request = {}
        self.result_shuttle_request = {}
        self.waiting_for_result = {}
        self.checkpoint_proof = None
        self.checkpoint_position = None
        self.replica_slot = 0
        self.completed_check_point_count = 0
        self.current_slot_id = {}
        self.running_state_log = []
        self.running_state_log.append((0, dict()))

        ## Flags for fault injections ##
        self.is_invalid_order_sig = False
        self.is_invalid_result_sig = False
        self.is_drop_shuttle = False
        self.is_truncate_history = False

    def run():
        self.state = 'ACTIVE'
        output("[Replica",self.index,":] Started: ", self.type, self.state, self.config_id)
        await(some(received(('terminate_replica'))))

    def performOperation(action):
        operation = action.operation
        output("[Replica",self.index,":] Perform: ", operation.toString())
        import re
        import copy
        matches = re.findall(r"\'(.+?)\'", operation.command)

        key = None
        value = None

        if not operation.type is 2 :
            key = matches[0]
            value = matches[1]
        else:
            key = matches[0]

        if operation.type is 1:
            self.database[key] = value
            self.running_state_log.append((action.replica_slot, copy.deepcopy(self.database)))
            return 'OK'
        elif operation.type is 2:
            if key in self.database:
                self.running_state_log.append((action.replica_slot, copy.deepcopy(self.database)))
                return self.database[key]
            else:
                self.running_state_log.append((action.replica_slot, copy.deepcopy(self.database)))
                return ''
        elif operation.type is 3:
            limit = value.split(':')
            if key in self.database and len(self.database[key]) >= int(limit[1]):
                val = self.database[key]
                self.database[key] = val[int(limit[0]):int(limit[1])]
                self.running_state_log.append((action.replica_slot, copy.deepcopy(self.database)))
                return 'OK'
            else:
                self.running_state_log.append((action.replica_slot, copy.deepcopy(self.database)))
                return 'FAIL'
        elif operation.type is 4:
            if key in self.database:
                val = self.database[key]
                list_val = val+value
                self.database[key] = list_val
                self.running_state_log.append((action.replica_slot, copy.deepcopy(self.database)))
                return 'OK'
            else:
                self.running_state_log.append((action.replica_slot, copy.deepcopy(self.database)))
                return 'FAIL'

    def receive(msg = ('init_hist', replica_list)):
        self.state = 'ACTIVE'
        self.replicaList = replica_list

    def receive(msg = ('req_operation', operation, client, client_index)):
        ## If the replica is head node, it will create a forward shuttle
        if self.type == 'head' and state == 'ACTIVE':
            output("[Replica",self.index,":]<< req_operation: ", operation.toString(), " Client: ", client_index)

            check_point_time = False
            #### assign slot number ######
            try:
                self.current_slot_id[client_index] += 1
            except KeyError:
                self.current_slot_id[client_index] = 1
            self.replica_slot += 1
            output("Slot: ", self.replica_slot, " : Operation: ", operation.toString())
            ######### Create action ###########
            class_action = import_da('Action')
            action = class_action.Action()

            if self.is_failure_increment_slot("client_request", str(client_index), str(self.current_slot_id[client_index])):
                output("[Replica",self.index,":] Fault: Increment slot injected")
                action.replica_slot = self.replica_slot + 1
            else:
                action.replica_slot = self.replica_slot

            action.seq_id = self.current_slot_id[client_index]
            action.operation = operation
            order_proof = []
            result_proof = []

            result = performOperation(action)

            ###### Create order statement #######
            class_order_statement = import_da('OrderStatement')
            order_statement = class_order_statement.OrderStatement()
            order_statement.order = "order"
            order_statement.action = action

            ##### Sign order statement, add to Order proof #######
            signed_order_statement = self.private_key.sign(pickle.dumps(order_statement))
            order_proof.append(signed_order_statement)

            ###### Create result statement ######
            class_result_statement = import_da('ResultStatement')
            result_statement = class_result_statement.ResultStatement()
            result_statement.result_const = "result"
            result_statement.action = action

            ######## Crypto hash of result #########
            result_statement.result = calculate_result_digest(result)

            ##### sign result statement, add to result proof #######
            signed_result_statement = self.private_key.sign(pickle.dumps(result_statement))
            result_proof.append(signed_result_statement)

            ####### create forward shuttle and send #######
            class_shuttle = import_da('Shuttle')
            forward_shuttle = class_shuttle.Shuttle()
            forward_shuttle.action = action
            forward_shuttle.order_proof = order_proof
            forward_shuttle.result_proof = result_proof
            output("[Replica",self.index,":]>> Shuttle: ", action.operation.toString(), " to Replica: ", index+1)
            send(('forward_shuttle', self, forward_shuttle, client, client_index), to = self.replicaList[index + 1])

    def receive(msg = ('forward_shuttle', replica, forward_shuttle, client, client_index)):
        action = forward_shuttle.action
        output("[Replica",self.index,":]<< Shuttle: ", action.operation.toString(), " from Replica: ", index-1)

        result = None
        try:
            self.shuttle_request[client_index] += 1
        except KeyError:
            self.shuttle_request[client_index] = 1

        ## fetch result proof and order proof list from shuttle
        order_proof = forward_shuttle.order_proof
        result_proof = forward_shuttle.result_proof

        ##### validate orderproof #######
        is_valid = validate_order_proof(action,order_proof)

        if not is_valid:
            output("[Replica",self.index,":] Invalid Order Proof, Sending Reconfig request. Become Immutable")
            self.state = 'IMMUTABLE'
            send(('req_re_configuration', config_id), to = olympus)
        elif self.running_state_log[len(self.running_state_log)-1][0] + 1 != forward_shuttle.action.replica_slot:
            output("[Replica",self.index,":] Holes in the slot number. Become Immutable")
            self.state = 'IMMUTABLE'
            send(('req_re_configuration', config_id), to = olympus)

        ################################ Failure Injections for phase 3 #######################################
        if client_index in self.shuttle_request :
            if self.is_failure_invalid_order_sig("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                output("[Replica",self.index,":] Fault: Invalid Order Sig injected")
                self.is_invalid_order_sig = True
            elif self.is_failure_invalid_result_sig("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Invalid Result Sig injected")
                    self.is_invalid_result_sig = True
            elif self.is_failure_crash("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Crash Replica injected")
                    crash()
            elif self.is_failure_sleep("shuttle", str(client_index), str(self.shuttle_request[client_index])) != -1:
                    timer = self.is_failure_sleep("shuttle", str(client_index), str(self.shuttle_request[client_index]))
                    output("[Replica",self.index,":] Fault: Sleep injected for time:", timer, " seconds")
                    sleep(timer)
            elif self.is_failure_drop("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Drop message Injected")
                    self.is_drop_shuttle = True
            elif self.is_failure_extra_op("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Extra Op Injected inserting Put('a', 'a')")
                    extra_op(forward_shuttle)
            elif self.is_failure_truncate_history("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Truncate history injected removing last entry from history")
                    is_truncate_history = True
      #########################################################################################################

        ### normal replica will add its order and result statement
        ### in shuttle and forward to  next Replica
        if type == 'normal_replica' and state == 'ACTIVE':

            verify_key = self.private_key.verify_key

            ##### Create order statement #####
            class_order_statement = import_da('OrderStatement')
            order_statement = class_order_statement.OrderStatement()
            order_statement.order = "order"

            #### fault injection scenario
            if client_index in self.shuttle_request :
                if self.is_failure_change_operation("shuttle",str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Change Operation, Client ", client_index, ", Request ",self.shuttle_request[client_index])
                    order_statement = self.change_operation(action, order_statement)
                    result = performOperation(order_statement.action)
                    output("[Replica",self.index,":] Successfully injected fault: Change operation")
                elif self.is_failure_change_result("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Change Result, Client ", client_index, ", Request: ",self.shuttle_request[client_index])
                    order_statement.action = action
                    result = "OK"
                    output("[Replica",self.index,":] Successfully injected fault: Change result")
                elif self.is_failure_drop_result_stmt("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Omit Head Result, Client ", client_index, ", Request ",self.shuttle_request[client_index])
                    order_statement.action = action
                    result = performOperation(action)
                    del result_proof[0]
                    output("[Replica",self.index,":] Successfully injected fault: Omit Head Result")
                else:
                    #output("[Replica",self.index,":] No fault Injected ", client_index, " Corresponding to request ",self.shuttle_request[client_index])
                    order_statement.action = action
                    result = performOperation(action)

            ########### Sign order statement, Add to order proof ###########
            signed_order_statement = self.private_key.sign(pickle.dumps(order_statement))
            if self.is_invalid_order_sig :
                signed_order_statement = invalid_sign(signed_order_statement)
                self.is_invalid_order_sig = False
            order_proof.append(signed_order_statement)

            ######## Create result statement ########
            class_result_statement = import_da('ResultStatement')
            result_statement = class_result_statement.ResultStatement()
            result_statement.result_const = "result"
            result_statement.action = action

            ###### Crypto hash of result #######
            result_statement.result= calculate_result_digest(result)

            ####### Sign Result Statement, Add to result_proof ###############
            signed_result_statement = self.private_key.sign(pickle.dumps(result_statement))
            if self.is_invalid_result_sig :
                signed_result_statement = invalid_sign(signed_result_statement)
                self.is_invalid_result_sig = False
            result_proof.append(signed_result_statement)

            ######## Forward Shuttle #######
            if self.is_drop_shuttle == False:
                output("[Replica",self.index,":]>> Shuttle: ", action.operation.toString(), " to Replica: ", index+1)
                send(('forward_shuttle', self, forward_shuttle, client, client_index), to = self.replicaList[index + 1])
            else:
                output("[Replica",self.index,":]>> Stopped the shuttle to go forward ")
                self.is_drop_shuttle = False


        ## If replica is a tail node, it will create a result shuttle
        if type == 'tail' and state == 'ACTIVE':

            ## Create Order statement
            class_order_statement = import_da('OrderStatement')
            order_statement = class_order_statement.OrderStatement()
            order_statement.order = "order"

            ## failure inject scenario
            if client_index in self.shuttle_request :
                if self.is_failure_change_operation("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Change operation, Client ", client_index, ", Request ",self.shuttle_request[client_index])
                    order_statement = self.change_operation(action, order_statement)
                    result = performOperation(order_statement.action)
                    output("[Replica",self.index,":] Successfully injected fault: Change operation")
                elif self.is_failure_change_result("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Change result, Client ", client_index, ", Request ",self.shuttle_request[client_index])
                    order_statement.action = action
                    result = "OK"
                    output("[Replica",self.index,":] Successfully injected fault: Change result")
                elif self.is_failure_drop_result_stmt("shuttle", str(client_index), str(self.shuttle_request[client_index])):
                    output("[Replica",self.index,":] Fault: Omit Head Result, Client ", client_index, ", Request ",self.shuttle_request[client_index])
                    order_statement.action = action
                    result = performOperation(action)
                    del result_proof[0]
                    output("[Replica",self.index,":] Successfully injected fault: Omit Head Result")
                else:
                    order_statement.action = action
                    result = performOperation(action)

            ##### Sign Order statement, Add to order proof
            signed_order_statement = self.private_key.sign(pickle.dumps(order_statement))
            if self.is_invalid_order_sig :
                signed_order_statement = invalid_sign(signed_order_statement)
                self.is_invalid_order_sig = False
            order_proof.append(signed_order_statement)

            ##### Create Result statement ###
            class_result_statement = import_da('ResultStatement')
            result_statement = class_result_statement.ResultStatement()
            result_statement.result_const = "result"
            result_statement.action = action

            ##### Crypto hash of result ######
            result_digest = calculate_result_digest(result)
            result_statement.result = result_digest

            ##### Sign Result statement, Add to Result proof
            signed_result_statement = self.private_key.sign(pickle.dumps(result_statement))
            if self.is_invalid_result_sig :
                signed_result_statement = invalid_sign(signed_result_statement)
                self.is_invalid_result_sig = False
            result_proof.append(signed_result_statement)

            ##### Send Result to Client ######
            if not self.is_drop_shuttle:
                send(('res_operation', action.operation, result, result_proof), to=client)
                output("[Replica",self.index,":]>> res_operation: ", action.operation.toString(), " result: ", result)


            ###### Create Result Shuttle #####
            class_shuttle = import_da('Shuttle')
            result_shuttle = class_shuttle.Shuttle()

            ###### Add action, result proof to shuttle ####
            result_shuttle.action = action
            result_shuttle.result_proof = result_proof

            ###### validate Result proof #######
            is_valid = validate_result_proof(result_digest, result_shuttle.result_proof)

            ## if not valid, enter into IMMUTABLE state
            ## else add it into its history and send to previous replica
            if not is_valid:
                output("Replica",self.index,":>> Result proof doesnot verify, State changed to Immutable, Reconfig Request to Olympus")
                self.state = 'IMMUTABLE'
                send(('req_re_configuration', config_id), to = olympus)
            elif not self.is_drop_shuttle:
                self.history.append(((action, result), result_shuttle))
                output("[Replica",self.index,":]>> Result Shuttle: ", action.operation.toString(), " to Replica: ", index-1)
                send(('result_shuttle', self, result_shuttle, result, client_index), to = self.replicaList[index - 1])
            else:
                self.is_drop_shuttle = False

    def receive(msg = ('result_shuttle', replica, result_shuttle, result, client_index)):
        ##### validating result proof #####
        temp_result = result
        result_digest = calculate_result_digest(temp_result)
        is_valid = validate_result_proof(result_digest, result_shuttle.result_proof)

        ###### If result proof is invalid, become immutable ######
        if not is_valid:
            self.state = 'IMMUTABLE'
            ## Reconfig
            send(('req_re_configuration', config_id), to = olympus)

        ##### if result proof is valid, add in history ######
        if is_valid  and state == 'ACTIVE':
            action = result_shuttle.action
            self.history.append(((action, result), result_shuttle))

            ##### Kill any running timer ######
            if action.operation.client_request_id in self.waiting_for_result:
                wait_operation = self.waiting_for_result[action.operation.client_request_id]
                if wait_operation[0] == 1 and\
                    wait_operation[1] == action.operation.client_seq_id:
                    wait_operation[0] = 0
                    wait_operation[1] = None
                    self.waiting_for_result[action.operation.client_request_id] = wait_operation

            output("[Replica",self.index,":]<< Result Shuttle: ", action.operation.toString(), " to Replica: ", index+1)
            ## fault injection case
            try:
                self.result_shuttle_request[client_index] += 1
            except KeyError:
                self.result_shuttle_request[client_index] = 1

            ## fault injection scenario
            if client_index in self.shuttle_request\
                and self.is_failure_change_result("result_shuttle", str(client_index), str(self.result_shuttle_request[client_index])):
                output("[Replica",self.index,":] Fault: Change result, Client ", client_index, ", Request ",self.result_shuttle_request[client_index])
                temp_result = "OK"

                ###### Cryptohash of result ######
                result_digest = calculate_result_digest(temp_result)

                ## unsign the result statement and overwrite the new result
                result_statement = result_shuttle.result_proof[self.index]
                verify_key = nacl.signing.VerifyKey(public_keys[self.index], encoder=nacl.encoding.HexEncoder)
                unsigned_result_statement = pickle.loads(verify_key.verify(result_statement))
                unsigned_result_statement.result = result_digest

                ## resign the result_statement and replace it in result_proof
                signed_result_statement = self.private_key.sign(pickle.dumps(unsigned_result_statement))
                result_shuttle.result_proof[self.index] = signed_result_statement

                output("[Replica",self.index,":] Successfully injected fault: Change result")

            elif client_index in self.shuttle_request\
                and self.is_failure_drop_result_stmt("result_shuttle", str(client_index), str(self.result_shuttle_request[client_index])):
                output("[Replica",self.index,":] Fault: Omit Head Result, Client ", client_index, ", Request ",self.result_shuttle_request[client_index])
                del result_shuttle.result_proof[0]

                output("[Replica",self.index,":] Successfully injected fault: Omit Head result")

            if not type == 'head' and state == 'ACTIVE':
                ## send the shuttle to next replica
                output("[Replica",self.index,":]>> Result Shuttle: ", action.operation.toString(), " to Replica: ", index-1)
                send(('result_shuttle', self, result_shuttle, result, client_index), to = replicaList[index - 1])
            else :
                #### Create check point shuttle after every 30 sequence #####
                if result_shuttle.action.replica_slot % 30 == 0 :
                    class_check_point_statement = import_da('CheckPointStatement')
                    check_point_statement = class_check_point_statement.CheckPointStatement()
                    check_point_statement.check_point_upto = result_shuttle.action.replica_slot
                    check_point_statement.running_state = {}
                    try:
                        check_point_statement.running_state = insert_entries(self.index)
                    except TypeError:
                        output("333333333333333 HERE")
                    ##### Crypto hash of check point running state ######
                    running_state_digest = calculate_running_state_digest(check_point_statement.running_state)
                    check_point_statement.running_state = running_state_digest

                    #### Sign Check Point Statement and add to checkpoint proof ####
                    signed_check_point_statement = self.private_key.sign(pickle.dumps(check_point_statement))
                    check_point_proof = []
                    check_point_proof.append(signed_check_point_statement)

                    ###### Create check point shuttle and send ######
                    class_shuttle = import_da('Shuttle')
                    check_point_shuttle = class_shuttle.Shuttle()
                    check_point_shuttle.check_point_proof = check_point_proof
                    output("[Replica",self.index,":]>> Sending Check Point Shuttle: to Replica: ", index+1)
                    send(('check_point_shuttle', self, check_point_shuttle, result_shuttle.action.replica_slot), to = replicaList[index + 1])

    def receive(msg = ('check_point_shuttle', replica, check_point_shuttle, check_point_upto)):

        output("[Replica",self.index,"]: Received check point shuttle: ", check_point_upto)
        running_state = insert_entries(self.index)

        ##### Crypto hash of check point running state ######
        running_state_digest = calculate_running_state_digest(running_state)

        ##### validate check point proof #######
        is_valid = validate_check_point_proof(check_point_shuttle.check_point_proof, running_state_digest)

        if not is_valid:
            output("[Replica",self.index,":] Invalid CheckPoint Proof, State Immutable, Reconfig to Olympus")
            self.state = 'IMMUTABLE'
            send(('req_re_configuration', config_id), to = olympus)

        output("[Replica",self.index,"]: Check point shuttle verified")
        verify_key = self.private_key.verify_key

        #### Create check point shuttle #####
        class_check_point_statement = import_da('CheckPointStatement')
        check_point_statement = class_check_point_statement.CheckPointStatement()
        check_point_statement.check_point_upto = check_point_upto
        check_point_statement.running_state = insert_entries(self.index)

        ##### Crypto hash of check point running state ######
        running_state_digest = calculate_running_state_digest(check_point_statement.running_state)
        check_point_statement.running_state = running_state_digest

        #### Sign Check Point Statement and add to checkpoint proof ####
        signed_check_point_statement = self.private_key.sign(pickle.dumps(check_point_statement))

        ### normal replica will add its check point statement ###
        if type == 'normal_replica' and state == 'ACTIVE':

            check_point_proof = check_point_shuttle.check_point_proof
            check_point_proof.append(signed_check_point_statement)

            ######## Forward Check Point Shuttle #######
            output("[Replica",self.index,":]>> Check Point Shuttle: to Replica: ", index+1)
            send(('check_point_shuttle', self, check_point_shuttle, check_point_upto), to = self.replicaList[index + 1])


        ## If replica is a tail node, it will create a result shuttle
        if type == 'tail' and state == 'ACTIVE':

            check_point_proof = check_point_shuttle.check_point_proof
            check_point_proof.append(signed_check_point_statement)

            ###### Create check point shuttle and send ######
            class_shuttle = import_da('Shuttle')
            completed_check_point_shuttle = class_shuttle.Shuttle()
            completed_check_point_shuttle.check_point_proof = check_point_proof

            ##### Remove entries from its history upto the check point ####
            output("[Replica",self.index,"]: Removing entries from history upto :", check_point_upto, " : history length: ", len(self.history))
            self.history = self.history[30:]
            self.checkpoint_position = check_point_statement.check_point_upto
            self.checkpoint_proof = completed_check_point_shuttle.check_point_proof

            ######## Send Completed Check Point Shuttle #######
            output("[Replica",self.index,":]>> Completed Check Point Shuttle: to Replica: ", index - 1)
            send(('completed_check_point_shuttle', self, completed_check_point_shuttle, check_point_upto), to = replicaList[self.index - 1])

    def receive(msg = ('completed_check_point_shuttle', replica, completed_check_point_shuttle, check_point_upto)):

        output("[Replica",self.index,"]: Received completed check point shuttle")
        self.completed_check_point_count += 1
        running_state = insert_entries(self.index)

        ##### Crypto hash of check point running state ######
        running_state_digest = calculate_running_state_digest(running_state)

        ##### validate completed check point proof #######
        is_valid = validate_check_point_proof(completed_check_point_shuttle.check_point_proof, running_state_digest)

        if not is_valid:
            output("[Replica",self.index,":] Invalid Completed CheckPoint Proof, State Immutable, Reconfig to Olympus")
            self.state = 'IMMUTABLE'
            send(('req_re_configuration', config_id), to = olympus)
        else:

            output("[Replica",self.index,"]: Completed Check point shuttle verified")

            #if is_failure_drop_check_pt_stmt(self.completed_check_point_count)

            ##### Remove entries from its history upto the check point ####
            output("[Replica",self.index,"]: Removing entries from history upto :", check_point_upto, " : history length: ", len(self.history))
            self.history = self.history[30:]
            output("[Replica",self.index,"]: New History :", len(self.history))
            self.checkpoint_position = check_point_upto
            self.checkpoint_proof = completed_check_point_shuttle.check_point_proof

            ######## Send Completed Check Point Shuttle #######
            if not type == 'head' and state == 'ACTIVE':
                output("[Replica",self.index,":]>> Completed Check Point Shuttle: to Replica: ", index - 1)
                send(('completed_check_point_shuttle', self, completed_check_point_shuttle, check_point_upto), to = replicaList[self.index - 1])

    def receive(msg = ('req_operation_timeout', operation, source, client, client_index)):
        if self.state == 'ACTIVE':
            if source == "client":
                output("[Replica",self.index,":]<< req_operation_timeout: ", operation.toString(), " Client: ", client_index)
            else:
                output("[Replica",self.index,":]<< req_operation_timeout: ", operation.toString(), " from Replica[no history], Client: ", client_index)
            (found_in_history, value) = foundInHistory(operation)

            if found_in_history == True:
                try:
                    (result_shuttle, result) = value
                except Exception:
                    output("[Replica",self.index,":] Not in History: ", operation.toString())

                ##fault injection scenario
                fault_trigger = "client_request" if source == "client" else "forwarded_request"

                try:
                    if source == "client":
                        self.direct_client_request[client_index] += 1
                    else:
                        self.forwarded_request[client_index] += 1
                except KeyError:
                    if source == "client":
                        self.direct_client_request[client_index] = 1
                    else:
                        self.forwarded_request[client_index] = 1

                message_number = str(self.direct_client_request[client_index]) if source == "client" else str(self.forwarded_request[client_index])

                if client_index in self.shuttle_request and self.is_failure_change_result(fault_trigger, str(client_index), message_number):
                    output("[Replica",self.index,":] Fault: Change Result,Client ", client_index, ", Request ",message_number)
                    temp_result = "OK"

                    ##### Crypto Hash of faulty result #####
                    result_digest = calculate_result_digest(temp_result)

                    ## un-sign the result statement and overwrite the new result
                    result_statement = result_shuttle.result_proof[self.index]
                    verify_key = nacl.signing.VerifyKey(self.public_keys[self.index], encoder=nacl.encoding.HexEncoder)
                    unsigned_result_statement = pickle.loads(verify_key.verify(result_statement))
                    unsigned_result_statement.result = result_digest

                    ## re-sign the result_statement and replace it in result_proof
                    signed_result_statement = self.private_key.sign(pickle.dumps(unsigned_result_statement))
                    result_shuttle.result_proof[self.index] = signed_result_statement

                elif client_index in self.shuttle_request and self.is_failure_drop_result_stmt(fault_trigger, str(client_index), message_number):
                    output("[Replica",self.index,":] Fault: Omit Head Result, Client ", client_index, ", Request ",self.direct_client_request[client_index])
                    del result_shuttle.result_proof[0]

                output("[Replica",self.index,":]>> res_operation_timeout: ",operation.toString(), " result: ", result, " to Client")
                send(('res_operation_timeout', operation, result_shuttle.result_proof, result, self, self.index, None), to=client)

            elif found_in_history == False and not self.type == 'head':
                output("[Replica",self.index,":]>> res_operation_timeout: ",operation.toString(), " to Head Replica")
                send(('req_operation_timeout', operation, "replica", client, client_index), to=self.replicaList[0])
                self.waiting_for_result[operation.client_request_id] = (1, operation.client_seq_id)
                if await(self.waiting_for_result[operation.client_request_id][0] == 0): pass
                elif timeout(self.timeout):
                    output("[Replica",self.index,":] Timeout!! Sending Reconfig Request")
                    self.waiting_for_result[operation.client_request_id] = (0, None)
                    self.state = 'IMMUTABLE'
                    send(('req_re_configuration', config_id), to = olympus)

            elif found_in_history == False and self.type == 'head':
                try:
                    if operation.client_seq_id > self.current_slot_id[client_index]:
                        #treat as new request
                        send(('req_operation', operation, client, client.index), to=self)
                    else:
                        try:
                            self.waiting_for_result[operation.client_request_id] = (1, operation.client_seq_id)
                        except:pass

                        if await(self.waiting_for_result[operation.client_request_id][0]== 0): pass
                        elif timeout(self.timeout):
                            output("[Replica",self.index,":] Timeout!! Sending Reconfig Request")
                            self.waiting_for_result[operation.client_request_id] = (0, None)
                            self.state = 'IMMUTABLE'
                            send(('req_re_configuration', config_id), to = olympus)
                except:
                    send(('req_operation', operation, client, client.index), to=self)

        elif self.state == 'IMMUTABLE':
            output("[Replica",self.index,":]<< req_operation_timeout: IMMUTABLE: ", operation.toString(), " Client: ", client_index)
            send(('res_operation_timeout', None, None, None, self, self.index, 'error'), to=client)

    def receive(msg = ('wedge')):
        output("[Replica",self.index,":]<< wedge")
        self.state = 'IMMUTABLE'
        output("[Replica",self.index,":]>> wedged")
        if is_failure_crash("wedged_request", -1, self.config_id):
            crash()
        elif is_failure_sleep("wedged_request", -1, self.config_id) > 0:
            timer = is_failure_sleep("wedged_request", -1, self.config_id)
            sleep(timer)
        #elif is_failure_truncate_history("wedged_request", -1, self.config_id) :
            #TODO: implement both inside and function definition


        send(('wedged', database, history, self.checkpoint_proof, self.checkpoint_position, index), to = olympus)

    def receive(msg = ('catch-up', catch_up_history)):
        output("[Replica",self.index,":]<< catch-up")
        output("[Replica",self.index,":] catch-up History")
        for i in range(len(catch_up_history)):
            ((action, result), proof) = catch_up_history[i]
            output("[Replica",self.index,":] catch-up History: Slot: ", action.replica_slot, ", operation: ", action.operation.toString())

        if len(catch_up_history) > 0:
            state = catchUpWithLongestHistory(catch_up_history)
        else:
            state = self.running_state_log[len(self.running_state_log)-1]
        output("[Replica",self.index,":]>> caught-up")
        send(('caught-up', state[1], self.index), to = olympus)

    def catchUpWithLongestHistory(catch_up_history):
        #TODO: perform operation with slot number greater than last_state
        ((action, result), proof) = catch_up_history[len(catch_up_history)-1]
        state = self.running_state_log[action.replica_slot]
        output("[Replica",self.index,":]>> catchUpWithLongestHistory: ", state)
        return state
        #last_state = self.running_state_log[len(self.running_state_log)-1]
        #output("[Replica",self.index,":]>> catchUpWithLongestHistory: ", last_state)
        #for i in range(len(catch_up_history)):
            #((action, result), proof) = catch_up_history[i]
            #if(action.replica_slot <= last_state[0])

    def foundInHistory(operation):
        for ((action, result), result_shuttle) in self.history:
            if action.operation.client_request_id == operation.client_request_id and\
                action.operation.command == operation.command and\
                action.operation.client_seq_id == operation.client_seq_id and\
                action.operation.type == operation.type:
                    return (True, (result_shuttle, result))
        return (False, None)

    ############ Failure Detectors #################
    def is_failure_change_operation(type, client, message):
        try:
            (source, (c,m)) = self.fault_map["change_operation()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_change_result(type, client, message):
        try:
            (source, (c,m)) = fault_map["change_result()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_drop_result_stmt(type, client, message):
        try:
            (source, (c,m)) = fault_map["drop_result_stmt()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_drop_check_pt_stmt(type, client, message):
        try:
            (source, (c,m)) = fault_map["drop_checkpt_stmts()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_invalid_result_sig(type, client, message):
        try:
            (source, (c,m)) = fault_map["invalid_result_sig()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_invalid_order_sig(type, client, message):
        try:
            (source, (c,m)) = fault_map["invalid_order_sig()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_sleep(type, client, message) :
        output("12##### fault map is", fault_map, "###########")
        try:
            for key in fault_map:
                if 'sleep' in key:
                    return int(key[key.find("(")+1:key.find(")")])
            return -1
        except KeyError:
            return -1

    def is_failure_crash(type, client, message):
        try:
            (source, (c,m)) = fault_map["crash()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_drop(type, client, message) :
        try:
            (source, (c,m)) = fault_map["drop()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_extra_op(type, client, message) :
        try:
            (source, (c,m)) = fault_map["extra_op()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_truncate_history(type, client, message) :
        try:
            (source, (c,m)) = fault_map["truncate_history()"]
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False

    def is_failure_increment_slot(type, client, message) :
        output("###########", type, client, message, "#############")
        output("##### fault map is", self.fault_map, "###########")
        try:
            (source, (c,m)) = self.fault_map["increment_slot()"]
            output("123###########", source, c, m, "#############")
            if (type, (client, message)) == (source, (c,m)):
                return True
        except KeyError:
            return False
    #####################################################################

    ########################## Failures Injected ############################
    def change_operation(action, order_statement) :
        output("[Replica",self.index,":] !!!!!! Changing operation from ", action.operation.command , " to get('X') !!!!!!!")
        class_action = import_da('Action')
        temp_action = class_action.Action()

        temp_action.replica_slot = action.replica_slot
        temp_action.seq_id = action.seq_id
        temp_action.operation = action.operation
        temp_action.operation.type = 2
        temp_action.operation.command = "('X')"

        order_statement.action = temp_action
        return order_statement

    def crash() :
        import os
        os._exit(-1)

    def truncate_history(history):
        return history[0 : len(history) - 1]

    def sleep(timer):
        import time
        time.sleep(timer)

    def invalid_sign(sig) :
        signedlist = list(sig)
        signedlist[0] = (signedlist[0] + 1) % 256
        newsigned = bytes(signedlist)
        invalid_signed = nacl.signing.SignedMessage._from_parts(sig._signature, sig._message, newsigned)
        return invalid_signed

    def extra_op(shuttle) :

        class_action = import_da('Action')
        action = class_action.Action()

        action.replica_slot = shuttle.action.replica_slot
        action.seq_id = shuttle.action.seq_id

        action.operation = import_da('Operation').Operation()
        action.operation.type = 1
        action.operation.client_seq_id = shuttle.action.operation.client_seq_id
        action.operation.command = "('a', 'a')"
        shuttle.action.replica_slot += 1

        performOperation(action)

    ############################################################################

    def calculate_result_digest(result):
        HASHER = nacl.hash.sha256
        result_byte = pickle.dumps(result)
        result_digest = HASHER(result_byte, encoder=nacl.encoding.HexEncoder)
        return result_digest

    def calculate_running_state_digest(running_state):
        HASHER = nacl.hash.sha256
        running_state_byte = pickle.dumps(running_state)
        running_state_digest = HASHER(running_state_byte, encoder=nacl.encoding.HexEncoder)
        return running_state_digest

    def validate_result_proof(result, result_proof):
        for i in range(len(result_proof)):
            verify_key = nacl.signing.VerifyKey(public_keys[i], encoder=nacl.encoding.HexEncoder)
            try:
                unsigned_result_statement = pickle.loads(verify_key.verify(result_proof[i]))
                if(unsigned_result_statement.result != result):
                    return False
            except Exception:
                return False
        return True

    def validate_check_point_proof(check_point_proof, running_state):
        for i in range(len(check_point_proof)):
            verify_key = nacl.signing.VerifyKey(public_keys[i], encoder=nacl.encoding.HexEncoder)
            try:
                unsigned_check_point_statement = pickle.loads(verify_key.verify(check_point_proof[i]))
                if(unsigned_check_point_statement.running_state != running_state):
                    output("###########", unsigned_check_point_statement.running_state, "#############", running_state)
                    return False
            except Exception:
                output("[Replica",self.index,":] Invalid Check Point Proof, Become Immutable, send Wedge to Olympus")
                return False
        return True

    def validate_order_proof(action, order_proof) :
        for i in range(len(order_proof)) :
            verify_key = nacl.signing.VerifyKey(self.public_keys[i], encoder=nacl.encoding.HexEncoder)
            try:
                unsigned_order_statement = pickle.loads(verify_key.verify(order_proof[i]))
                unsigned_operation = unsigned_order_statement.action.operation
                client_operation = action.operation
                if not unsigned_operation.isEqual(client_operation):
                    output("[Replica",self.index,":] Result doesnot match so returning false")
                    return False
            except KeyError:
                return False
            except Exception:
                return False
        return True

    def insert_entries(index) :
        running_state = []
        for i in range(30) :
            result_statement = self.history[i][1].result_proof[index]
            verify_key = nacl.signing.VerifyKey(self.public_keys[index], encoder=nacl.encoding.HexEncoder)
            unsigned_result_statement = pickle.loads(verify_key.verify(result_statement))
            running_state.append((unsigned_result_statement.action.replica_slot, unsigned_result_statement.result))
        return running_state

def main():
    test_case = sys.argv[1]
    ip = None
    try:
        ip = sys.argv[2]
    except Exception:
        pass
    config = {}
    failure_list = []
    with open(test_case,'r') as f:
        for line in f:
            if line[0] != '#':
                (key,sep,val) = line.partition('=')
                # if the line does not contain '=', it is invalid and hence ignored
                if len(sep) != 0:
                    val = val.strip()
                    config[key.strip()] = int(val) if str.isdecimal(val) else val

    #class_olympus = import_da('Olympus')
    class_client = import_da('Client')
    num_replica = 2 * config['t'] + 1

    for key in config:
        if "failures" in key:
            failure_list.append((key,config[key]))

    olympus_node = 'OlympusNode' + '@' + ip if ip is not None else 'OlympusNode'
    olympus = new(Olympus, args=(num_replica, config['head_timeout'], config['nonhead_timeout'], failure_list), at=olympus_node)
    clientList = new(class_client.Client, num= config['num_client'])
    i = 0
    for client in clientList:
        load = 'workload[' + str(i) + ']'
        setup(client, args=(olympus, i, config[str(load)], config['client_timeout']))
        i += 1

    config(channel = Fifo, clock = Lamport)
    start(olympus)
    start(clientList)
